#!/bin/bash
#
# sysconf-etc.d - update config files as defined in /etc/sysconf/meta.d
#
# HISTORY
#   20140821 first version by JF Gigand <jf@geonef.fr>

#
# Options:
#
#
#
# Naming:
#
# Types:
#   "concatenation":
#

nef_command_name=sysconf-etc.d
. $(dirname $0)/../share/nef-common/shell-command || exit 2


######################################################################
# DEFAULTS

SYSCONF_ETC_BASE_PATH=/etc/sysconf/etc.d
SYSCONF_ETC_CONFIG_GENERATED_TOKEN="GENERATED BY sysconf-etc.d"
SYSCONF_ETC_CONFIG_COMMENT_LEAD="# "
SYSCONF_ETC_CONFIG_COMMENT_TRAIL=""
SYSCONF_ETC_CONFIG_EXT=
SYSCONF_ETC_CONFIG_HEADER=
SYSCONF_ETC_CONFIG_FOOTER=
# if empty, source_conf_d will be deduced from $SYSCONF_ETC_CONFIG_TARGET_CONF
SYSCONF_ETC_CONFIG_SOURCE_CONF_D=
# if empty, owner of target config file is not modified
SYSCONF_ETC_CONFIG_OWNER=

SYSCONF_ETC_CONFIG_ONCHANGE_HOOK() {
    true
}

######################################################################
# COMMANDS

# command: help [command]
#
# Print information about command usage.
#
# With no argument, a list of commands is printed.
##
script_command_help() {
    local _argv=()
    local _command=
    local _usage=0

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h) script_command_help help; return ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _command="$1"; break ;;
        esac
    done

    nef_show_help $_command
}

# command: list
#
# Dump a list of configured meta-configs
##
script_command_list() {
    local _argv=()
    local _command=
    local _usage=0
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h) script_command_help help; return ;;
            --) shift; _argv=("${_argv[@]}" "$@"); shift $# ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -gt 0 ] && nef_fatal_usage_command handle-remote-protocol "too many arguments"

    script_foreach_config script_list_config "${_argv[@]}"
}

script_list_config() {
    nef_log "$SYSCONF_ETC_CONFIG_PATH"
}

# command: status [<config>]
#
# Show the status of given or all config
##
script_command_status() {
    local _argv=()
    local _command=
    local _usage=0
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h) script_command_help help; return ;;
            --) shift; _argv=("${_argv[@]}" "$@"); shift $# ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    script_foreach_config script_status_config "${_argv[@]}"
}

script_status_config() {
    nef_log "=== $SYSCONF_ETC_CONFIG_PATH"
    set -o posix
    set | grep ^SYSCONF_ETC_CONFIG_ | sed 's/SYSCONF_ETC_CONFIG_//' | nef_log_pipe
    nef_log
}

# command: update [<config>]
#
# Update the config according to /etc/sysconf/etc.d/<config>
##
script_command_update() {
    local _argv=()
    local _command=
    local _usage=0
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h) script_command_help help; return ;;
            --) shift; _argv=("${_argv[@]}" "$@"); shift $# ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    script_foreach_config script_update_config "${_argv[@]}"
}

script_update_config() {

    local configpath=$SYSCONF_ETC_CONFIG_TARGET_CONF
    local configfile=$(basename "$configpath")
    local configdir_d=$SYSCONF_ETC_CONFIG_SOURCE_CONF_D
    if [ -z "$configdir_d" ]; then
        local configdir=$(dirname "$configpath")
        local configdir_d="$configdir/$configfile.d"
    fi

    if [ -z "$SYSCONF_ETC_CONFIG_EXT" ]; then
        SYSCONF_ETC_CONFIG_EXT="$configfile"
    fi

    if [ ! -d $configdir_d ]; then
        nef_log -v "$configdir_d does not exist. $configpath won't be updated."
        return
    fi

    # files=$configdir_d/*.$SYSCONF_ETC_CONFIG_EXT
    # files=$(find $configdir_d -not -type d | grep -v '~$' | grep -v '\.bak*')
    files=$(find $configdir_d -name "*.$SYSCONF_ETC_CONFIG_EXT" -and -not -type d)
    filecount=$(echo $files | wc -w)

    if [ $filecount -eq 0 ]; then
        nef_log -v "no '*.$SYSCONF_ETC_CONFIG_EXT' files found in $configdir_d. $configpath won't be updated."
        return
    fi

    [ -f "$configpath" ] && {
	if ! grep -q "$SYSCONF_ETC_CONFIG_GENERATED_TOKEN" "$configpath"; then
            nef_log -v "$configpath does not seem to be an auto-generated file. Not updating."
            return
        fi
    }

    nef_log -v "Generating $configpath out of: $configdir_d/"
    content="$SYSCONF_ETC_CONFIG_HEADER"$'\n'

    case $SYSCONF_ETC_CONFIG_TYPE in
        concatenation)
            for file in $files; do
	        nef_log -v "Including file: $file"
	        filecontent=$(cat $file)
	        content="$content"$'\n'"${SYSCONF_ETC_CONFIG_COMMENT_LEAD}${file}${SYSCONF_ETC_CONFIG_COMMENT_TRAIL}"$'\n'"$filecontent"
            done
            ;;
        reference)
	    content="$content"$'\n'"$SYSCONF_ETC_CONFIG_BEGIN"
            for file in $files; do
	        nef_log -v "Reference file: $file"
                local escaped=$(echo "$file" | sed 's/\//\\\//g')
                local ref=$(echo "$SYSCONF_ETC_CONFIG_EXPRESSION" | sed "s/%p/${escaped}/")
	        content="$content"$'\n'"$ref"
            done
            ;;
        *)
            nef_fatal "Invalid config type: $SYSCONF_ETC_CONFIG_TYPE"
            ;;
    esac

    content="${content}${SYSCONF_ETC_CONFIG_FOOTER}"
    _temp=$(mktemp)
    _md5=$(md5sum "$configpath" 2>/dev/null | sed 's/ .*//')
    # echo -e "${SYSCONF_ETC_CONFIG_COMMENT_LEAD}${SYSCONF_ETC_CONFIG_GENERATED_TOKEN}${SYSCONF_ETC_CONFIG_COMMENT_TRAIL}\n${content}" \
    #     >"$_temp"

cat <<EOF >"$_temp"
${SYSCONF_ETC_CONFIG_COMMENT_LEAD}${SYSCONF_ETC_CONFIG_GENERATED_TOKEN}${SYSCONF_ETC_CONFIG_COMMENT_TRAIL}
${SYSCONF_ETC_CONFIG_COMMENT_LEAD}DO NOT EDIT! Instead, edit: ${configdir_d}${SYSCONF_ETC_CONFIG_COMMENT_TRAIL}
${SYSCONF_ETC_CONFIG_COMMENT_LEAD}Then update this file by running: $0 update ${SYSCONF_ETC_CONFIG_NAME}${SYSCONF_ETC_CONFIG_COMMENT_TRAIL}
${content}
EOF

    if [ "$_md5" != "$(md5sum $_temp | sed 's/ .*//')" ]; then
        if [ -f "${configpath}" -a ! -f "${configpath}.orig" ]; then
            nef_log -v "Backing up initial file to: ${configpath}.orig"
            cp "$configpath" "$configpath.orig"
        elif [ -f "${configpath}" ]; then
            nef_log -v "Backing up former file to: ${configpath}.bak"
            cp "${configpath}" "${configpath}.bak"
        else
            local _dir=$(dirname $configpath)
            local _ifs="$IFS"; IFS=/
            local _parts=( $_dir ); IFS="$_ifs"
            local _base=
            # unset ${_parts[0]}
            for _part in "${_parts[@]}"; do
                if [ -n "$_part" ]; then
                    if [ ! -d $_base/$_part ]; then
                        mkdir $_base/$_part
                        if [ -n "$SYSCONF_ETC_CONFIG_OWNER" ]; then
                            nef_log "Setting ownership '$SYSCONF_ETC_CONFIG_OWNER' to created dir: $_base/$_part"
                            chown $SYSCONF_ETC_CONFIG_OWNER $_base/$_part
                        fi
                    fi
                    _base=$_base/$_part
                fi
            done
        fi
        cat $_temp >"${configpath}"
        rm -f $_temp
        count=$(wc -l $configpath | sed 's/ .*//')
        if [ -n "$SYSCONF_ETC_CONFIG_OWNER" ]; then
            nef_log "Setting ownership to: $SYSCONF_ETC_CONFIG_OWNER"
            chown $SYSCONF_ETC_CONFIG_OWNER $configpath
        fi
        nef_log "Wrote $configpath with $count lines out of $filecount file(s)"

        SYSCONF_ETC_CONFIG_ONCHANGE_HOOK
    else
        nef_log -v "Content has not changed actually: $configpath"
        rm -f "$_temp"
    fi
}


######################################################################
# FUNCTIONALITY

script_foreach_config() {
    local _command="$1"
    shift
    local _configs=("$@")

    if [ ${#_configs[@]} -eq 0 ]; then
        nef_log -v "Scanning dir: $SYSCONF_ETC_BASE_PATH"
        OLD_IFS="$IFS"
        IFS="
"
        _configs=( $(for file in $(ls $SYSCONF_ETC_BASE_PATH/*.meta.conf); do \
            basename "$file" .meta.conf; done ) )
        IFS="$OLD_IFS"

        if [ ${#_configs[@]} -eq 0 ]; then
            nef_fatal "no config specified and none found in $SYSCONF_ETC_BASE_PATH"
        fi
    fi

    for SYSCONF_ETC_CONFIG_NAME in ${_configs[@]}; do
        (
            nef_command_name=
            NEF_LOG_PREFIX_NOCOLUMN=yes
            SYSCONF_ETC_CONFIG_PATH=$SYSCONF_ETC_BASE_PATH/${SYSCONF_ETC_CONFIG_NAME}.meta.conf
            [ -f $SYSCONF_ETC_CONFIG_PATH ] || nef_fatal "file does not exist: $SYSCONF_ETC_CONFIG_PATH"

            nef_log -v "Processing: $SYSCONF_ETC_CONFIG_PATH"
            . $SYSCONF_ETC_CONFIG_PATH

            $_command
        ) 2>&1 | nef_log_pipe "$SYSCONF_ETC_CONFIG_NAME:"
    done
}

######################################################################
# COMMAND LINE & RUN

script_eval_common_option() {
    case "$1" in
        -v | --verbose) nef_opt_show_verbose=yes; shift ;;
        -vv | --debug-verbose) nef_opt_show_verbose=yes; nef_opt_show_debug=yes; shift ;;
        -h | --help) nef_show_usage; exit 0 ;;
        -*) nef_fatal "bad option: $1, use -h for usage information" ;;
    esac
}

nef_fatal_usage_command() {
    local _command="$1"; shift

    nef_log "$_command usage error: $*"
    echo >&2
    script_command_help --usage "$_command" >&2
    exit 1
}

script_parse_cmdline() {
    nef_command_merge_env
    nef_command_init_options

    script_command_argv=()

    while [ -n "$1" ]; do

        case "$1" in
            -*) script_eval_common_option "$1"; shift ;;
            *) script_command_argv=("$@"); break ;;
        esac

    done

    [ -z "${script_command_argv[0]}" ] && script_command_argv=(help)

    # Run command
    script_command_function_name="script_command_${script_command_argv[0]}"
    unset script_command_argv[0]
    $script_command_function_name "${script_command_argv[@]}" \
        || nef_fatal "command ${script_command_argv[0]} returned status $?"
    nef_log -v "Command returned successfully."
}

######################################################################

script_parse_cmdline "$@"
