#!/bin/bash
#
# gitted-client: manage a Gitted target system like a Git repository
#
# Gitted is a shell framework that turn a UNIX system into a Git repository
# where the machine state is seen as a "Git working data" which can be
# checked out/commited from/to Git branches (the "IO" branches).
#
# This client command provides 3 functionalities:
#   - send Gitted commands to a target system (commit, reset, status)
#   - forward Git push/pull to target (using the Git ext:: remote protocol)
#   - integrate both for easy use from the "git" command (register)
#
## HISTORY
#    20140818 first version by JF Gigand <jf@geonef.fr>
#    20150222 reconception around "IO commit" and partial rewrite using new sysconf-target
##

nef_command_name=gitted-client
nef_command_prefix=script_command
gitted_executive_treeish=

# Source 'shell-command' from sysconf.base and find sysconf-target
script_dir=$(dirname $(readlink -f $0))
PATH=$script_dir/../share/nef-common:$script_dir/../../../../sysconf.base/tree/usr/share/nef-common:/usr/share/nef-common . shell-command
if [ $? -ne 0 ]; then
    echo "FATAL ERROR: could not find share/nef-common/shell-command" >&2
    exit 2
fi
sysconf_target_command=$(PATH=$script_dir:$script_dir/../../../../sysconf.base/tree/usr/bin:$PATH which sysconf-target)
[ -z "$sysconf_target_command" ] && nef_fatal "could not find: sysconf-target"


######################################################################
# COMMANDS: GITTED SERVER

# command: commit [[<target>] <io>...] [-m <message>]
#
# Commit IO state to Git branch within target
##
script_command_commit() {
    true
}

# command: reset [[<target>] <io> [commit]] [--soft] [--coming]
#
# Reset target IO state to branch head or given commit
##
script_command_reset() {
    true
}

# command: status [[<target>] <io>]
#
# Show status of target IO state
##
script_command_commit() {
    true
}

######################################################################
# COMMANDS: GIT INTEGRATION

# command: register [git-config-file] [what]
#
# Setup Git configuration for "git ted" alias and "gitted:" URL rewriting
#
# [git-config-file] designates where the config is written, as given to git-config(1):
#
#       --local         Write to the repository .git/config file.
#                       This is the default behavior.
#
#       --system        Write to system-wide \$(prefix)/etc/gitconfig rather
#                       than the repository .git/config.
#
#       --global        Write to global ~/.gitconfig file rather than the
#                       repository .git/config.
#
#       --file config-file, -f config-file
#                       Use the given config file instead of the one specified
#                       by GIT_CONFIG
#
# [what] designates what is setup. If not given, all things are setup. These are:
#
#       --alias         Configures alias.ted to !(...)/gitted-client
#       --url           Configures gitted: URL rewriting to ext::(...)gitted-client(...)
##
script_command_register() {
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            -h|--help) script_command_help init; return ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -gt 0 ] && nef_fatal_usage_command init "too many arguments"

    script_check_env
    nef_log "Copying $0 to GIT dir..."
    script_ensure_script_in_git_dir
}
script_ensure_script_in_git_dir() {
    cp $0 $script_git_dir/$nef_command_name \
        || nef_fatal "could not copy $0 to $script_git_dir/$nef_command_name"
    commit=$(git rev-parse HEAD)
    sed -i -r "s/^(script_executive_treeish)=(.*)/\1=$commit/" $script_git_dir/$nef_command_name
    # cp $(dirname $0)/gitted-server-setup $script_git_dir/
}


# command: git-upload-pack <target>
#
# Forward Git protocol to target's "gitted git-receive-pack".
#
# This is not meant to be used directly, but through Git remote commands
# such as git-fetch(1).
#
# Usage examples:
#   git fetch "ext::/path/to/gitted-client %S lxc:container" sysconf
#   git fetch "ext::/path/to/gitted-client %S ssh:user@host" mysql
#
# After running "gitted-client register", you may use the "gitted:" scheme:
#   git fetch gitted:lxc:container sysconf
#   git fetch gitted:ssh:user@host mysql
#
# Or define it as a remote:
#   git remote add container gitted:lxc:container
#   git fetch container sysconf
#   git checkout -b sysconf
##
script_command_git-upload-pack() {
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            -h|--help) script_command_help git-upload-pack; return ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -lt 1 ] && nef_fatal_usage_command git-upload-pack "missing argument(s)"
    [ "${#_argv[@]}" -gt 1 ] && nef_fatal_usage_command git-upload-pack "too many arguments"

    local _target="${_argv[0]}"

    nef_log "target = $_target"
}

# command: git-receive-pack <target>
#
# Forward Git protocol to target's "gitted git-receive-pack".
#
# This is not meant to be used directly, but through Git remote commands such as
# git-push(1).
#
# Usage examples:
#   git push "ext::/path/to/gitted-client %S lxc:container" sysconf
#   git push "ext::/path/to/gitted-client %S ssh:user@host" mysql_bak:mysql
#
# After running "gitted-client register", you may use the "gitted:" scheme:
#   git push gitted:lxc:container mysql
#   git push gitted:ssh:user@host mysql_bak:mysql
#
# Or define it as a remote:
#   git remote add container gitted:lxc:container
#   git push container sysconf
##
script_command_git-receive-pack() {
    local _argv=()

    while [ -n "$1" ]; do
        case "$1" in
            -h|--help) script_command_help git-receive-pack; return ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _argv=("${_argv[@]}" "$1"); shift ;;
        esac
    done

    [ "${#_argv[@]}" -lt 1 ] && nef_fatal_usage_command git-receive-pack "missing argument(s)"
    [ "${#_argv[@]}" -gt 1 ] && nef_fatal_usage_command git-receive-pack "too many arguments"

    local _target="${_argv[0]}"

    nef_log "target = $_target"
}


######################################################################
# COMMANDS: OTHER

# command: help [command]
#
# Print information about command usage.
#
# With no argument, a list of commands is printed.
##
script_command_help() {
    local _argv=()
    local _command=
    local _usage=0

    while [ -n "$1" ]; do
        case "$1" in
            --usage) _usage=1; shift ;;
            -h|--help) script_command_help help; return ;;
            -*) script_eval_common_option "$1"; shift ;;
            *) _command="$1"; break ;;
        esac
    done

    nef_show_help $_command
}

######################################################################
# FUNCTIONALITY




######################################################################
# COMMAND LINE & RUN

script_eval_common_option() {
    case "$1" in
        -v | --verbose) nef_opt_show_verbose=yes; shift ;;
        -vv | --debug-verbose) nef_opt_show_verbose=yes; nef_opt_show_debug=yes; shift ;;
        -h | --help) nef_show_usage; exit 0 ;;
        -*) nef_fatal "bad option: $1, use -h for usage information" ;;
    esac
}

nef_fatal_usage_command() {
    local _command="$1"; shift

    nef_log "$_command usage error: $*"
    echo >&2
    script_command_help --usage "$_command" >&2
    exit 1
}

script_parse_cmdline() {
    nef_command_merge_env
    nef_command_init_options

    script_command_argv=()

    while [ -n "$1" ]; do

        case "$1" in
            -*) script_eval_common_option "$1"; shift ;;
            *) script_command_argv=("$@"); break ;;
        esac

    done

    [ -z "${script_command_argv[0]}" ] && script_command_argv=(help)

    # Seek .git directory
    script_git_dir=$(git rev-parse --git-dir)
    echo "$script_git_dir" | grep -q / || {
        script_git_dir=$PWD/$script_git_dir
    }
    [ -z "$script_git_dir" ] && nef_fatal "not in GIT directory or working tree"

    # Run command
    script_command_function_name="script_command_${script_command_argv[0]}"
    unset script_command_argv[0]
    declare -f $script_command_function_name >/dev/null \
        || nef_fatal_usage "invalid command: ${script_command_argv[0]}"
    $script_command_function_name "${script_command_argv[@]}" \
        || nef_fatal "command ${script_command_argv[0]} failed with status $?"
    nef_log -v "Command returned successfully."
}


######################################################################

script_parse_cmdline "$@"
